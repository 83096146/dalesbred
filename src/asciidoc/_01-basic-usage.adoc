== Basic usage

=== Configuring the database connection

Most things in Dalesbred happen through an instance of {javadocBase}org/dalesbred/Database.html[Database].
The easiest way to get hold of one is to specify the settings manually:

[source,java]
----
Database db = Database.forUrlAndCredentials("jdbc:example-url", "login", "password");
----

Note that this performs no connection pooling and is therefore probably not
your preferred way of configuring the system in production. In a container
you'll probably want to use a named {jdkJavadocBase}javax/sql/DataSource.html[DataSource] lookup up from JNDI:

[source,java]
----
Database db = Database.forJndiDataSource("java:comp/env/jdbc/ExampleDb");
----

Alternatively, you might setup a {jdkJavadocBase}javax/sql/DataSource.html[DataSource] yourself, in which case you can
just create a {javadocBase}org/dalesbred/Database.html[Database] out of that:

[source,java]
----
Database db = Database.forDataSource(myDataSource);
----

If you are using http://projects.spring.io/spring-framework/[Spring Framework], see the
<<_spring,Spring>>-section on how to integrate Dalesbred with it.

=== Finding stuff

Finding simple results consisting of just basic types is simple:

[source,java]
----
List<Integer> newIds = db.findAll(Integer.class,
    "select id from department where created_date > ?", date);
----

To fetch results with multiple columns, usually you'd use a class with matching constructor:

[source,java]
----
List<Department> departments =
    db.findAll(Department.class, "select id, name from department");

public final class Department {
    private final int id;
    private final String name;

    public Department(int id, String name) {
        this.id = id;
        this.name = name;
    }

    ...
}
----

If there are more columns in the result-set than can be given to a constructor, then the rest of the
columns are set using properties or direct field access. So even the following would work:

[source,java]
----
List<Department> departments =
    db.findAll(Department.class, "select id, name from department");

...

public final class Department {
    public int id;
    public String name;
}
----

And if you have nested objects, you can bind to them as well as long as all objects in the path are instantiated:

[source,java]
----
List<Employee> departments =
    db.findAll(Employee.class, "select id, first_name as \"name.first\", last_name as \"name.last\" from employee");

...

public final class Employee {
    public int id;
    public final Name name = new Name();
}

public final class Name {
    public String first;
    public String last;
}
----

You can also convert the results directly to a map:

[source,java]
----
Map<Integer,String> namesByIds = db.findMap(
        Integer.class, String.class, "select id, name from department");

// first column is used for key, rest for instantiating the value
Map<Integer,Department> departmentsByIds = db.findMap(
        Integer.class, Department.class, "select id, id, name from department");

----

If for some reason you don't want to map the results into your own class, you can ask for
a {javadocBase}org/dalesbred/result/ResultTable.html[ResultTable], which is basically a detached
representation of a {jdkJavadocBase}java/sql/ResultSet.html[ResultSet]:

[source,java]
----
ResultTable employees = db.findTable("select * from employee");
----

Alternatively, you can supply your own {javadocBase}org/dalesbred/result/RowMapper.html[RowMapper] or
{javadocBase}org/dalesbred/result/ResultSetProcessor.html[ResultSetProcessor]-implementation in place
of the class and handle the result sets manually, but usually this should be unnecessary.

=== Updates

Normal updates are straightforward, since we don't need to do much work to map the results:

[source,java]
----
int modifiedRows = db.update("delete from user where id=?", 42);
----

If you plan to return stuff from updates, they are queries as far as Dalesbred is concerned:

[source,java]
----
int id = db.findUniqueInt("insert into department (name) values ('foo') returning id");
----
